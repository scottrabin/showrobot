#!/usr/bin/env ruby

# ensure ShowRobot's lib directory is in Ruby's load path
$LOAD_PATH.unshift(File.dirname(__FILE__) + '/../lib') unless $LOAD_PATH.include?(File.dirname(__FILE__) + '/../lib')

# load the cli tools
Dir[File.dirname(__FILE__) + '/../lib/showrobot/cli/*.rb'].each { |file| require File.expand_path(file) }

SUBCOMMANDS = %w(rename identify config)
command = ARGV.shift
abort "#{BASIC_USAGE}\nShowRobot expects subcommand [#{SUBCOMMANDS.join('|')}]\nRun `showrobot [command] -h` to see specific usage options" if not SUBCOMMANDS.include? command

# dependencies for parsing options
require 'trollop'

# load up ShowRobot
require 'showrobot'

# dispatch on command
case command.to_sym
when :config
	# going to need YAML
	require 'yaml'

	# configuration options
	options = Trollop::options {
		banner "Configure default options for ShowRobot\n"
		opt :global, "Modify the global options for ShowRobot", :default => false, :short => :g
		instance_eval &OptionSet[:config]
	}

	apply_options options

	file = opts[:global] ? File.dirname(__FILE__) + '/../config.yml' : ShowRobot.config[:config_file]

	conf = YAML::load(IO.read(file)) rescue {}

	# extend the loaded configuration
	while not ARGV.empty?
		prop, val = ARGV.shift 2
		conf[prop] = val

		printf "Setting [ %-12s ] to [ %-12s ]\n", prop, val if ShowRobot.config[:verbose]
	end

	# write to the file
	File.open(file, 'w') do |file|
		file.write conf.to_yaml
	end

when :rename
	# mkdir_p and mv
	require 'fileutils'

	options = Trollop::options do
		banner "Rename a file according to the specified format\n"

		# Configuration options
		instance_eval &OptionSet[:config]

		# Cache options
		instance_eval &OptionSet[:cache]

		# Database options
		instance_eval &OptionSet[:database]

		# File options
		instance_eval &OptionSet[:file]

		# Rename-specific options
		opt :movie_format, "Define the output filename for movies", :type => String, :short => :m
		opt :tv_format, "Define the output filename for TV shows", :type => String, :short => :t
		opt :dry_run, "Dry run; don't touch the files", :default => false, :short => :D
		opt :space_replace, "Replace spaces in the output file name with the specified character", :default => " ", :short => :r
	end

	apply_options options

	# loop through the video files
	ARGV.select { |file| ShowRobot::MediaFile.isvideo? file }.each do |file|
		media = ShowRobot::MediaFile.load file

		if options[:force_movie] or (media.is_movie? and not options[:force_tv])
			# TODO
		else options[:force_tv] or (media.is_tv? and not options[:force_movie])
			identity = identify media, ShowRobot.config[:tv_database], options[:prompt]
			filename_format = translate options[:tv_format], {
				'{s}' => '%<season>02d',
				'{e}' => '%<episode>02d',
				'{n}' => '%<series>s',
				'{t}' => '%<title>s',
				'{ext}' => File.extname(file).sub(/^\./, '')
			}
		end

		new_filename = File.expand_path(sprintf(filename_format, identity).gsub(/\s/, options[:space_replace]))

		puts "Would have performed the following operations:" if options[:dry_run]

		# ensure the target directory exists
		FileUtils.mkdir_p File.dirname(new_filename), :noop => options[:dry_run], :verbose => options[:dry_run]

		# if the file already exists, log an error
		if File.exists? new_filename
			ShowRobot.log :error, "mv failed (destination exists): [ #{file} ] --> [ #{new_filename} ]" if not options[:dry_run]
		else
			ShowRobot.log :info, "mv [ #{file} ] --> [ #{new_filename} ]" if not options[:dry_run]
			FileUtils.mv file, new_filename, :noop => options[:dry_run], :verbose => options[:dry_run] # verbosity here is covered by the logging statement
		end
	end
when :identify
else
	puts "Unknown subcommand: #{command.inspect}"
end
