#!/usr/bin/env ruby

# ensure ShowRobot's lib directory is in Ruby's load path
$LOAD_PATH.unshift(File.dirname(__FILE__) + '/../lib') unless $LOAD_PATH.include?(File.dirname(__FILE__) + '/../lib')

# dependencies for parsing options
require 'trollop'

# parse options
options = Trollop::options do
	# Media identification options
	opt :identify, "Identify a show from the filename", :default => false, :short => :i
	opt :database, "Use the specified database for the search", :default => 'tvrage', :short => :d

	# Cache control
	opt :cache_dir, "Use the specified directory for caching server queries", :default => nil, :type => String, :short => :c
	opt :no_cache, "Do not use caching for any queries", :default => false, :short => nil
	opt :clear_cache, "Clear the cache and start fresh with queries", :short => :C

	# Media file parsing options
	opt :duration, "Determine the length of a video file", :default => false, :short => :l
	opt :episode, "Determine the season and episode of a file from the filename", :default => false

	# Causes ShowRobot to display additional debugging information
	opt :verbose, "Show detailed information messages", :default => false
	# prompts user to choose amongst various options instead of deferring to the first
	opt :prompt, "Prompt for media file matches", :default => false, :short => :p
end
files = ARGV # Trollop modifies this, all that's left is the list of files

# open up the ShowRobot module and define some constants
module ShowRobot; end
ShowRobot::USE_CACHE = false if options[:no_cache]
ShowRobot::CACHE_DIRECTORY = options[:cache_dir] if options[:cache_dir]
ShowRobot::VERBOSE = options[:verbose]

# load up ShowRobot
require 'showrobot'

# clear the cache if necessary
if options[:clear_cache]
	puts "Clearing cache in [ #{ShowRobot::CACHE_DIRECTORY} ]" if ShowRobot::VERBOSE
	File.delete(*Dir[ShowRobot::CACHE_DIRECTORY + '/*.cache'])
end

# helper function for prompts
def select list, prompt, &format
	range = 0...10
	begin
		puts prompt
		range.each do |i|
			puts format.call i, list[i]
		end
		print " > "
		input = $stdin.gets.chomp

		case input
		when /^[\d]+$/
			# it's a number, make sure it's in the range
			selected = list[input.to_i] if input.to_i < list.length
		when 'n' # next range
			range = Range.new(range.end, [range.end + 10, list.length].min, true) if range.end < list.length
		when 'p' # prev range
			range = Range.new([0, range.first - 10].max, range.first, true) if range.first > 1
		when 'q'
			exit
		end
	end while selected.nil?
	selected
end

files.select { |file| ShowRobot::MediaFile.isvideo? file }.each do |file|
	puts "Processing file #{file}" if ShowRobot::VERBOSE
	media = ShowRobot::MediaFile.load file

	if options[:identify]
		if media.is_movie?

		else
			database = ShowRobot.create_datasource options[:database]
			database.mediaFile = media

			database.series = if options[:prompt]
								  select database.series_list, "Select a series for [ #{file} ]" do |index, item|
									  sprintf " %3d) %s", index, item[:name]
								  end
							  else
								  database.series_list.first
							  end

			episode = if options[:prompt]
						  select database.episode_list, "Select an episode for [ #{file} ]" do |index, item|
							  sprintf " %3d) [%02d.%02d] %s", index, item[:season], item[:episode], item[:name]
						  end
					  else
						  database.episode_list.first
					  end

			puts "Identified as: [ #{database.series[:name]} ] >> [#{episode[:season]}x#{episode[:episode]}] [ #{episode[:name]} ]" if ShowRobot::VERBOSE
		end
	end


	data = Array.new

	data << media.duration   if options[:duration]
	data << media.season << media.episode if options[:episode]

	print data.join "\t"
end
