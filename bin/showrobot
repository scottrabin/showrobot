#!/usr/bin/env ruby

# ensure ShowRobot's lib directory is in Ruby's load path
$LOAD_PATH.unshift(File.dirname(__FILE__) + '/../lib') unless $LOAD_PATH.include?(File.dirname(__FILE__) + '/../lib')

# dependencies for parsing options
require 'trollop'

# parse options
options = Trollop::options do
	# Media identification options
	opt :identify, "Identify a show from the filename", :default => false, :short => :i
	opt :database, "Use the specified database for the search", :default => 'tvrage', :short => :d

	# Cache control
	opt :cache_dir, "Use the specified directory for caching server queries", :default => nil, :type => String, :short => :c
	opt :no_cache, "Do not use caching for any queries", :default => false, :short => nil
	opt :clear_cache, "Clear the cache and start fresh with queries", :short => :C

	# Media file parsing options
	opt :duration, "Determine the length of a video file", :default => false, :short => :l
	opt :episode, "Determine the season and episode of a file from the filename", :default => false

	# Causes ShowRobot to display additional debugging information
	opt :verbose, "Show detailed information messages", :default => false
	# prompts user to choose amongst various options instead of deferring to the first
	opt :prompt, "Prompt for media file matches", :default => false, :short => :p
end
files = ARGV # Trollop modifies this, all that's left is the list of files

# open up the ShowRobot module and define some constants
module ShowRobot; end
ShowRobot::USE_CACHE = false if options[:no_cache]
ShowRobot::CACHE_DIRECTORY = options[:cache_dir] if options[:cache_dir]
ShowRobot::VERBOSE = options[:verbose]

# load up ShowRobot
require 'showrobot'

# clear the cache if necessary
if options[:clear_cache]
	puts "Clearing cache in [ #{ShowRobot::CACHE_DIRECTORY} ]" if ShowRobot::VERBOSE
	File.delete(*Dir[ShowRobot::CACHE_DIRECTORY + '/*.cache'])
end

files.select { |file| ShowRobot::MediaFile.isvideo? file }.each do |file|
	puts "Processing file #{file}" if ShowRobot::VERBOSE
	media = ShowRobot::MediaFile.load file

	if options[:identify]
		if media.is_movie?

		else
			seriesName = if options[:prompt]
							 # get the user's choice
						 else
							 media.series(options[:database]).first
						 end

			puts "Identified as series [ #{seriesName[0]} ]"
		end
	end


	data = Array.new

	data << media.duration   if options[:duration]
	data << media.season << media.episode if options[:episode]

	print data.join "\t"
end
